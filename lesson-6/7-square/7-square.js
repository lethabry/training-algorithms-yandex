// Городская площадь имеет размер n× m и покрыта квадратной плиткой размером 1× 1.
// При плановой замене плитки выяснилось, что новой плитки недостаточно для покрытия всей площади,
// поэтому было решено покрыть плиткой только дорожку по краю площади, а в центре площади разбить прямоугольную клумбу (см. рисунок к примеру).
// При этом дорожка должна иметь одинаковую ширину по всем сторонам площади. Определите максимальную ширину дорожки, которую можно выложить из имеющихся плиток.

// Формат ввода
// Первая и вторая строки входных данных содержат по одному числу n и m (3≤ n ≤ 2× 109, 3≤ m ≤ 2× 109) — размеры площади.
// Третья строка содержит количество имеющихся плиток t, 1≤ t< nm.
// Обратите внимание, что значение t может быть больше, чем возможное значение 32-битной целочисленной переменной,
// поэтому необходимо использовать 64-битные числа (тип int64 в языке Pascal, тип long long в C и C++, тип long в Java и C#).

// Формат вывода
// Программа должна вывести единственное число — максимальную ширину дорожки, которую можно выложить из имеющихся плиток.

// Пример
// Ввод
// 6
// 7
// 38

// Вывод
// 2

function findWidthSquare(data) {
  const [n, m, t] = data.toString(' ').trim().split('\n').map(BigInt);
  let l = 0n;
  let r = n <= m ? n : m;
  while (l < r) {
    let middle = (l + r + 1n) / 2n;
    if (isEnoughWidth(n, m, middle, t)) {
      l = middle;
    } else {
      r = middle - 1n;
    }
  }
  return l;
}

const isEnoughWidth = (n, m, middle, t) => {
  const square = n * m;
  const floweredSquare = (n - 2n * middle) * (m - 2n * middle);
  return square - floweredSquare <= t;
};

const fs = require('fs');
let fileContent = fs.readFileSync('input.txt', 'utf8');

const result = findWidthSquare(fileContent);

fs.writeFileSync('output.txt', result + '');
